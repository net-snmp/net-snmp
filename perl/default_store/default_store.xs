#if defined(_WIN32) && !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x501
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/library/default_store.h>


/* autogenerated by "gen" from const-c.inc */

#define PERL_constant_NOTFOUND	1
#define PERL_constant_NOTDEF	2
#define PERL_constant_ISIV	3
#define PERL_constant_ISNO	4
#define PERL_constant_ISNV	5
#define PERL_constant_ISPV	6
#define PERL_constant_ISPVN	7
#define PERL_constant_ISSV	8
#define PERL_constant_ISUNDEF	9
#define PERL_constant_ISUV	10
#define PERL_constant_ISYES	11

#ifndef NVTYPE
typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
#endif
#ifndef aTHX_
#define aTHX_ /* 5.6 or later define this for threading support.  */
#endif
#ifndef pTHX_
#define pTHX_ /* 5.6 or later define this for threading support.  */
#endif

static int
constant_22 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPTYPE NETSNMP_DS_LIB_CONTEXT NETSNMP_DS_LIB_MIBDIRS
     NETSNMP_DS_LIB_SECNAME */
  /* Offset 16 gives the best switch position.  */
  switch (name[16]) {
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_SECNAME", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_SECNAME
      *iv_return = NETSNMP_DS_LIB_SECNAME;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_MIBDIRS", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_MIBDIRS
      *iv_return = NETSNMP_DS_LIB_MIBDIRS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'O':
    if (memEQ(name, "NETSNMP_DS_LIB_CONTEXT", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_CONTEXT
      *iv_return = NETSNMP_DS_LIB_CONTEXT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_APPTYPE", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_APPTYPE
      *iv_return = NETSNMP_DS_LIB_APPTYPE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_23 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPTYPES NETSNMP_DS_LIB_SECLEVEL NETSNMP_DS_LIB_SECMODEL */
  /* Offset 18 gives the best switch position.  */
  switch (name[18]) {
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_SECLEVEL", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_SECLEVEL
      *iv_return = NETSNMP_DS_LIB_SECLEVEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_SECMODEL", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_SECMODEL
      *iv_return = NETSNMP_DS_LIB_SECMODEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'T':
    if (memEQ(name, "NETSNMP_DS_LIB_APPTYPES", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_APPTYPES
      *iv_return = NETSNMP_DS_LIB_APPTYPES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_24 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_16BIT_IDS NETSNMP_DS_LIB_COMMUNITY NETSNMP_DS_LIB_OIDPREFIX
     NETSNMP_DS_LIB_OIDSUFFIX */
  /* Offset 18 gives the best switch position.  */
  switch (name[18]) {
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_16BIT_IDS", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_16BIT_IDS
      *iv_return = NETSNMP_DS_LIB_16BIT_IDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_COMMUNITY", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_COMMUNITY
      *iv_return = NETSNMP_DS_LIB_COMMUNITY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_OIDPREFIX", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_OIDPREFIX
      *iv_return = NETSNMP_DS_LIB_OIDPREFIX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_OIDSUFFIX", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_OIDSUFFIX
      *iv_return = NETSNMP_DS_LIB_OIDSUFFIX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_25 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_APPLICATION_ID NETSNMP_DS_LIB_KSM_KEYTAB
     NETSNMP_DS_LIB_MIB_ERRORS NETSNMP_DS_LIB_PASSPHRASE
     NETSNMP_DS_SNMP_VERSION_1 NETSNMP_DS_SNMP_VERSION_3 */
  /* Offset 24 gives the best switch position.  */
  switch (name[24]) {
  case '1':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_", 24)) {
    /*                                       1      */
#ifdef NETSNMP_DS_SNMP_VERSION_1
      *iv_return = NETSNMP_DS_SNMP_VERSION_1;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case '3':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_", 24)) {
    /*                                       3      */
#ifdef NETSNMP_DS_SNMP_VERSION_3
      *iv_return = NETSNMP_DS_SNMP_VERSION_3;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_KSM_KEYTA", 24)) {
    /*                                       B      */
#ifdef NETSNMP_DS_LIB_KSM_KEYTAB
      *iv_return = NETSNMP_DS_LIB_KSM_KEYTAB;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'D':
    if (memEQ(name, "NETSNMP_DS_APPLICATION_I", 24)) {
    /*                                       D      */
#ifdef NETSNMP_DS_APPLICATION_ID
      *iv_return = NETSNMP_DS_APPLICATION_ID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_PASSPHRAS", 24)) {
    /*                                       E      */
#ifdef NETSNMP_DS_LIB_PASSPHRASE
      *iv_return = NETSNMP_DS_LIB_PASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_ERROR", 24)) {
    /*                                       S      */
#ifdef NETSNMP_DS_LIB_MIB_ERRORS
      *iv_return = NETSNMP_DS_LIB_MIB_ERRORS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_26 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_CLIENT_ADDR NETSNMP_DS_LIB_DUMP_PACKET
     NETSNMP_DS_LIB_MIB_REPLACE NETSNMP_DS_LIB_QUICK_PRINT
     NETSNMP_DS_LIB_SNMPVERSION NETSNMP_DS_SNMP_VERSION_2c */
  /* Offset 22 gives the best switch position.  */
  switch (name[22]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENT_ADDR", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_CLIENT_ADDR
      *iv_return = NETSNMP_DS_LIB_CLIENT_ADDR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_DUMP_PACKET", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_DUMP_PACKET
      *iv_return = NETSNMP_DS_LIB_DUMP_PACKET;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_REPLACE", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_MIB_REPLACE
      *iv_return = NETSNMP_DS_LIB_MIB_REPLACE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_2c", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_SNMP_VERSION_2c
      *iv_return = NETSNMP_DS_SNMP_VERSION_2c;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'R':
    if (memEQ(name, "NETSNMP_DS_LIB_QUICK_PRINT", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_QUICK_PRINT
      *iv_return = NETSNMP_DS_LIB_QUICK_PRINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_SNMPVERSION", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_SNMPVERSION
      *iv_return = NETSNMP_DS_LIB_SNMPVERSION;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_27 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DEFAULT_PORT NETSNMP_DS_LIB_MIB_WARNINGS
     NETSNMP_DS_LIB_QUICKE_PRINT NETSNMP_DS_LIB_REGEX_ACCESS */
  /* Offset 17 gives the best switch position.  */
  switch (name[17]) {
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_WARNINGS", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_MIB_WARNINGS
      *iv_return = NETSNMP_DS_LIB_MIB_WARNINGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'F':
    if (memEQ(name, "NETSNMP_DS_LIB_DEFAULT_PORT", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_DEFAULT_PORT
      *iv_return = NETSNMP_DS_LIB_DEFAULT_PORT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_REGEX_ACCESS", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_REGEX_ACCESS
      *iv_return = NETSNMP_DS_LIB_REGEX_ACCESS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_QUICKE_PRINT", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_QUICKE_PRINT
      *iv_return = NETSNMP_DS_LIB_QUICKE_PRINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_28 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHMASTERKEY NETSNMP_DS_LIB_CLIENTRECVBUF
     NETSNMP_DS_LIB_CLIENTSENDBUF NETSNMP_DS_LIB_ESCAPE_QUOTES
     NETSNMP_DS_LIB_LOG_TIMESTAMP NETSNMP_DS_LIB_PRIVMASTERKEY
     NETSNMP_DS_LIB_RANDOM_ACCESS NETSNMP_DS_LIB_SERVERRECVBUF
     NETSNMP_DS_LIB_SERVERSENDBUF */
  /* Offset 15 gives the best switch position.  */
  switch (name[15]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHMASTERKEY", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_AUTHMASTERKEY
      *iv_return = NETSNMP_DS_LIB_AUTHMASTERKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENTRECVBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_CLIENTRECVBUF
      *iv_return = NETSNMP_DS_LIB_CLIENTRECVBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENTSENDBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_CLIENTSENDBUF
      *iv_return = NETSNMP_DS_LIB_CLIENTSENDBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_ESCAPE_QUOTES", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_ESCAPE_QUOTES
      *iv_return = NETSNMP_DS_LIB_ESCAPE_QUOTES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_LOG_TIMESTAMP", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_LOG_TIMESTAMP
      *iv_return = NETSNMP_DS_LIB_LOG_TIMESTAMP;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVMASTERKEY", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_PRIVMASTERKEY
      *iv_return = NETSNMP_DS_LIB_PRIVMASTERKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'R':
    if (memEQ(name, "NETSNMP_DS_LIB_RANDOM_ACCESS", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_RANDOM_ACCESS
      *iv_return = NETSNMP_DS_LIB_RANDOM_ACCESS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_SERVERRECVBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_SERVERRECVBUF
      *iv_return = NETSNMP_DS_LIB_SERVERRECVBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_SERVERSENDBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_SERVERSENDBUF
      *iv_return = NETSNMP_DS_LIB_SERVERSENDBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_29 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHPASSPHRASE NETSNMP_DS_LIB_EXTENDED_INDEX
     NETSNMP_DS_LIB_OPTIONALCONFIG NETSNMP_DS_LIB_PERSISTENT_DIR
     NETSNMP_DS_LIB_PRINT_FULL_OID NETSNMP_DS_LIB_PRINT_HEX_TEXT
     NETSNMP_DS_LIB_PRIVPASSPHRASE NETSNMP_DS_LIB_REVERSE_ENCODE
     NETSNMP_DS_LIB_SBSM_LOCAL_PWD */
  /* Offset 23 gives the best switch position.  */
  switch (name[23]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_SBSM_LOCAL_PWD", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_SBSM_LOCAL_PWD
      *iv_return = NETSNMP_DS_LIB_SBSM_LOCAL_PWD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_OPTIONALCONFIG", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_OPTIONALCONFIG
      *iv_return = NETSNMP_DS_LIB_OPTIONALCONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_REVERSE_ENCODE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_REVERSE_ENCODE
      *iv_return = NETSNMP_DS_LIB_REVERSE_ENCODE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_FULL_OID", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRINT_FULL_OID
      *iv_return = NETSNMP_DS_LIB_PRINT_FULL_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_PERSISTENT_DIR", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PERSISTENT_DIR
      *iv_return = NETSNMP_DS_LIB_PERSISTENT_DIR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHPASSPHRASE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_AUTHPASSPHRASE
      *iv_return = NETSNMP_DS_LIB_AUTHPASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVPASSPHRASE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRIVPASSPHRASE
      *iv_return = NETSNMP_DS_LIB_PRIVPASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'X':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_HEX_TEXT", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRINT_HEX_TEXT
      *iv_return = NETSNMP_DS_LIB_PRINT_HEX_TEXT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case '_':
    if (memEQ(name, "NETSNMP_DS_LIB_EXTENDED_INDEX", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_EXTENDED_INDEX
      *iv_return = NETSNMP_DS_LIB_EXTENDED_INDEX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_30 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPEND_LOGFILES NETSNMP_DS_LIB_MIB_PARSE_LABEL
     NETSNMP_DS_LIB_NO_DISPLAY_HINT NETSNMP_DS_LIB_SAVE_MIB_DESCRS */
  /* Offset 27 gives the best switch position.  */
  switch (name[27]) {
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_PARSE_LABEL", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_MIB_PARSE_LABEL
      *iv_return = NETSNMP_DS_LIB_MIB_PARSE_LABEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_SAVE_MIB_DESCRS", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_SAVE_MIB_DESCRS
      *iv_return = NETSNMP_DS_LIB_SAVE_MIB_DESCRS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_NO_DISPLAY_HINT", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_NO_DISPLAY_HINT
      *iv_return = NETSNMP_DS_LIB_NO_DISPLAY_HINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_APPEND_LOGFILES", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_APPEND_LOGFILES
      *iv_return = NETSNMP_DS_LIB_APPEND_LOGFILES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_31 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHLOCALIZEDKEY NETSNMP_DS_LIB_DONT_CHECK_RANGE
     NETSNMP_DS_LIB_DONT_PRINT_UNITS NETSNMP_DS_LIB_HAVE_READ_CONFIG
     NETSNMP_DS_LIB_KSM_SERVICE_NAME NETSNMP_DS_LIB_MIB_COMMENT_TERM
     NETSNMP_DS_LIB_PRINT_BARE_VALUE NETSNMP_DS_LIB_PRIVLOCALIZEDKEY */
  /* Offset 28 gives the best switch position.  */
  switch (name[28]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_KSM_SERVICE_NAME", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_KSM_SERVICE_NAME
      *iv_return = NETSNMP_DS_LIB_KSM_SERVICE_NAME;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_COMMENT_TERM", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_MIB_COMMENT_TERM
      *iv_return = NETSNMP_DS_LIB_MIB_COMMENT_TERM;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'F':
    if (memEQ(name, "NETSNMP_DS_LIB_HAVE_READ_CONFIG", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_HAVE_READ_CONFIG
      *iv_return = NETSNMP_DS_LIB_HAVE_READ_CONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_PRINT_UNITS", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_DONT_PRINT_UNITS
      *iv_return = NETSNMP_DS_LIB_DONT_PRINT_UNITS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'K':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHLOCALIZEDKEY", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_AUTHLOCALIZEDKEY
      *iv_return = NETSNMP_DS_LIB_AUTHLOCALIZEDKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVLOCALIZEDKEY", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_PRIVLOCALIZEDKEY
      *iv_return = NETSNMP_DS_LIB_PRIVLOCALIZEDKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_BARE_VALUE", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_PRINT_BARE_VALUE
      *iv_return = NETSNMP_DS_LIB_PRINT_BARE_VALUE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_CHECK_RANGE", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_DONT_CHECK_RANGE
      *iv_return = NETSNMP_DS_LIB_DONT_CHECK_RANGE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_32 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT NETSNMP_DS_LIB_CONFIGURATION_DIR
     NETSNMP_DS_LIB_DONT_READ_CONFIGS NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
     NETSNMP_DS_LIB_NO_TOKEN_WARNINGS NETSNMP_DS_LIB_NUMERIC_TIMETICKS
     NETSNMP_DS_LIB_OID_OUTPUT_FORMAT NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
     NETSNMP_DS_LIB_TEMP_FILE_PATTERN */
  /* Offset 29 gives the best switch position.  */
  switch (name[29]) {
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_NUMERIC_TIMETICKS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_NUMERIC_TIMETICKS
      *iv_return = NETSNMP_DS_LIB_NUMERIC_TIMETICKS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_CONFIGURATION_DIR", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_CONFIGURATION_DIR
      *iv_return = NETSNMP_DS_LIB_CONFIGURATION_DIR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_TEMP_FILE_PATTERN", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_TEMP_FILE_PATTERN
      *iv_return = NETSNMP_DS_LIB_TEMP_FILE_PATTERN;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
      *iv_return = NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_READ_CONFIGS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_DONT_READ_CONFIGS
      *iv_return = NETSNMP_DS_LIB_DONT_READ_CONFIGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_OID_OUTPUT_FORMAT", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_OID_OUTPUT_FORMAT
      *iv_return = NETSNMP_DS_LIB_OID_OUTPUT_FORMAT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_NO_TOKEN_WARNINGS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_NO_TOKEN_WARNINGS
      *iv_return = NETSNMP_DS_LIB_NO_TOKEN_WARNINGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
      *iv_return = NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT
      *iv_return = NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_33 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_ALARM_DONT_USE_SIG NETSNMP_DS_LIB_DONT_PERSIST_STATE
     NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
     NETSNMP_DS_LIB_READ_UCD_STYLE_OID */
  /* Offset 32 gives the best switch position.  */
  switch (name[32]) {
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_READ_UCD_STYLE_OI", 32)) {
    /*                                               D      */
#ifdef NETSNMP_DS_LIB_READ_UCD_STYLE_OID
      *iv_return = NETSNMP_DS_LIB_READ_UCD_STYLE_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_PERSIST_STAT", 32)) {
    /*                                               E      */
#ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE
      *iv_return = NETSNMP_DS_LIB_DONT_PERSIST_STATE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_ALARM_DONT_USE_SI", 32)) {
    /*                                               G      */
#ifdef NETSNMP_DS_LIB_ALARM_DONT_USE_SIG
      *iv_return = NETSNMP_DS_LIB_ALARM_DONT_USE_SIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_NUMERIC_ENU", 32)) {
    /*                                               M      */
#ifdef NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM
      *iv_return = NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_NUMERIC_OID", 32)) {
    /*                                               S      */
#ifdef NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
      *iv_return = NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_34 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
     NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID */
  /* Offset 28 gives the best switch position.  */
  switch (name[28]) {
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD
      *iv_return = NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID
      *iv_return = NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY
      *iv_return = NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
      *iv_return = NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_38 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
     NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
     NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG */
  /* Offset 37 gives the best switch position.  */
  switch (name[37]) {
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOA", 37)) {
    /*                                                    D      */
#ifdef NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
      *iv_return = NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAV", 37)) {
    /*                                                    E      */
#ifdef NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
      *iv_return = NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFI", 37)) {
    /*                                                    G      */
#ifdef NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG
      *iv_return = NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant (pTHX_ const char *name, STRLEN len, IV *iv_return) {
  /* Initially switch on the length of the name.  */
  /* When generated this function returned values for the list of names given
     in this section of perl code.  Rather than manually editing these functions
     to add or remove constants, which would result in this comment and section
     of code becoming inaccurate, we recommend that you edit this section of
     code, and use it to regenerate a new set of constant functions which you
     then use to replace the originals.

     Regenerate these constant functions by feeding this entire source file to
     perl -x

#!/usr/bin/perl -w
use ExtUtils::Constant qw (constant_types C_constant XS_constant);

my $types = {map {($_, 1)} qw(IV)};
my @names = (qw(NETSNMP_DS_APPLICATION_ID NETSNMP_DS_LIBRARY_ID
	       NETSNMP_DS_LIB_16BIT_IDS NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT
	       NETSNMP_DS_LIB_ALARM_DONT_USE_SIG NETSNMP_DS_LIB_APPEND_LOGFILES
	       NETSNMP_DS_LIB_APPTYPE NETSNMP_DS_LIB_APPTYPES
	       NETSNMP_DS_LIB_AUTHLOCALIZEDKEY NETSNMP_DS_LIB_AUTHMASTERKEY
	       NETSNMP_DS_LIB_AUTHPASSPHRASE NETSNMP_DS_LIB_CLIENTRECVBUF
	       NETSNMP_DS_LIB_CLIENTSENDBUF NETSNMP_DS_LIB_CLIENT_ADDR
	       NETSNMP_DS_LIB_COMMUNITY NETSNMP_DS_LIB_CONFIGURATION_DIR
	       NETSNMP_DS_LIB_CONTEXT NETSNMP_DS_LIB_DEFAULT_PORT
	       NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD
	       NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
	       NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
	       NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
	       NETSNMP_DS_LIB_DONT_CHECK_RANGE
	       NETSNMP_DS_LIB_DONT_PERSIST_STATE
	       NETSNMP_DS_LIB_DONT_PRINT_UNITS NETSNMP_DS_LIB_DONT_READ_CONFIGS
	       NETSNMP_DS_LIB_DUMP_PACKET NETSNMP_DS_LIB_ESCAPE_QUOTES
	       NETSNMP_DS_LIB_EXTENDED_INDEX NETSNMP_DS_LIB_HAVE_READ_CONFIG
	       NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG
	       NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
	       NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY NETSNMP_DS_LIB_KSM_KEYTAB
	       NETSNMP_DS_LIB_KSM_SERVICE_NAME NETSNMP_DS_LIB_LOG_TIMESTAMP
	       NETSNMP_DS_LIB_MIBDIRS NETSNMP_DS_LIB_MIB_COMMENT_TERM
	       NETSNMP_DS_LIB_MIB_ERRORS NETSNMP_DS_LIB_MIB_PARSE_LABEL
	       NETSNMP_DS_LIB_MIB_REPLACE NETSNMP_DS_LIB_MIB_WARNINGS
	       NETSNMP_DS_LIB_NO_DISPLAY_HINT NETSNMP_DS_LIB_NO_TOKEN_WARNINGS
	       NETSNMP_DS_LIB_NUMERIC_TIMETICKS NETSNMP_DS_LIB_OIDPREFIX
	       NETSNMP_DS_LIB_OIDSUFFIX NETSNMP_DS_LIB_OID_OUTPUT_FORMAT
	       NETSNMP_DS_LIB_OPTIONALCONFIG NETSNMP_DS_LIB_PASSPHRASE
	       NETSNMP_DS_LIB_PERSISTENT_DIR NETSNMP_DS_LIB_PRINT_BARE_VALUE
	       NETSNMP_DS_LIB_PRINT_FULL_OID NETSNMP_DS_LIB_PRINT_HEX_TEXT
	       NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM
	       NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
	       NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
	       NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID
	       NETSNMP_DS_LIB_PRIVLOCALIZEDKEY NETSNMP_DS_LIB_PRIVMASTERKEY
	       NETSNMP_DS_LIB_PRIVPASSPHRASE NETSNMP_DS_LIB_QUICKE_PRINT
	       NETSNMP_DS_LIB_QUICK_PRINT NETSNMP_DS_LIB_RANDOM_ACCESS
	       NETSNMP_DS_LIB_READ_UCD_STYLE_OID NETSNMP_DS_LIB_REGEX_ACCESS
	       NETSNMP_DS_LIB_REVERSE_ENCODE NETSNMP_DS_LIB_SAVE_MIB_DESCRS
	       NETSNMP_DS_LIB_SBSM_LOCAL_PWD NETSNMP_DS_LIB_SECLEVEL
	       NETSNMP_DS_LIB_SECMODEL NETSNMP_DS_LIB_SECNAME
	       NETSNMP_DS_LIB_SERVERRECVBUF NETSNMP_DS_LIB_SERVERSENDBUF
	       NETSNMP_DS_LIB_SNMPVERSION NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT
	       NETSNMP_DS_LIB_TEMP_FILE_PATTERN NETSNMP_DS_MAX_IDS
	       NETSNMP_DS_MAX_SUBIDS NETSNMP_DS_SNMP_VERSION_1
	       NETSNMP_DS_SNMP_VERSION_2c NETSNMP_DS_SNMP_VERSION_3
	       NETSNMP_DS_TOKEN_ID));

print constant_types(); # macro defs
foreach (C_constant ("NetSNMP::default_store", 'constant', 'IV', $types, undef, 3, @names) ) {
    print $_, "\n"; # C constant subs
}
print "#### XS Section:\n";
print XS_constant ("NetSNMP::default_store", $types);
__END__
   */

  switch (len) {
  case 18:
    if (memEQ(name, "NETSNMP_DS_MAX_IDS", 18)) {
#ifdef NETSNMP_DS_MAX_IDS
      *iv_return = NETSNMP_DS_MAX_IDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 19:
    if (memEQ(name, "NETSNMP_DS_TOKEN_ID", 19)) {
#ifdef NETSNMP_DS_TOKEN_ID
      *iv_return = NETSNMP_DS_TOKEN_ID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 21:
    /* Names all of length 21.  */
    /* NETSNMP_DS_LIBRARY_ID NETSNMP_DS_MAX_SUBIDS */
    /* Offset 11 gives the best switch position.  */
    switch (name[11]) {
    case 'L':
      if (memEQ(name, "NETSNMP_DS_LIBRARY_ID", 21)) {
      /*                          ^                */
#ifdef NETSNMP_DS_LIBRARY_ID
        *iv_return = NETSNMP_DS_LIBRARY_ID;
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'M':
      if (memEQ(name, "NETSNMP_DS_MAX_SUBIDS", 21)) {
      /*                          ^                */
#ifdef NETSNMP_DS_MAX_SUBIDS
        *iv_return = NETSNMP_DS_MAX_SUBIDS;
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    }
    break;
  case 22:
    return constant_22 (aTHX_ name, iv_return);
    break;
  case 23:
    return constant_23 (aTHX_ name, iv_return);
    break;
  case 24:
    return constant_24 (aTHX_ name, iv_return);
    break;
  case 25:
    return constant_25 (aTHX_ name, iv_return);
    break;
  case 26:
    return constant_26 (aTHX_ name, iv_return);
    break;
  case 27:
    return constant_27 (aTHX_ name, iv_return);
    break;
  case 28:
    return constant_28 (aTHX_ name, iv_return);
    break;
  case 29:
    return constant_29 (aTHX_ name, iv_return);
    break;
  case 30:
    return constant_30 (aTHX_ name, iv_return);
    break;
  case 31:
    return constant_31 (aTHX_ name, iv_return);
    break;
  case 32:
    return constant_32 (aTHX_ name, iv_return);
    break;
  case 33:
    return constant_33 (aTHX_ name, iv_return);
    break;
  case 34:
    return constant_34 (aTHX_ name, iv_return);
    break;
  case 35:
    if (memEQ(name, "NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT", 35)) {
#ifdef NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT
      *iv_return = NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 36:
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT", 36)) {
#ifdef NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT
      *iv_return = NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;

  case 38:
    return constant_38 (aTHX_ name, iv_return);
    break;
  }
  return PERL_constant_NOTFOUND;
}

/* autogenerated by "gen" from const-xs.inc */

MODULE = NetSNMP::default_store         PACKAGE = NetSNMP::default_store

void
constant(sv)
    PREINIT:
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv = 0;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
    INPUT:
	SV *		sv;
        const char *	s = SvPV(sv, len);
    PPCODE:
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid NetSNMP::default_store macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined NetSNMP::default_store macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing NetSNMP::default_store macro %s, used",
               type, s));
          PUSHs(sv);
        }



int
netsnmp_ds_get_boolean(storeid, which)
	int	storeid
	int	which

int
netsnmp_ds_get_int(storeid, which)
	int	storeid
	int	which

char *
netsnmp_ds_get_string(storeid, which)
	int	storeid
	int	which

void *
netsnmp_ds_get_void(storeid, which)
	int	storeid
	int	which

int
netsnmp_ds_register_config(type, ftype, token, storeid, which)
	unsigned char	type
	const char *	ftype
	const char *	token
	int	storeid
	int	which

int
netsnmp_ds_register_premib(type, ftype, token, storeid, which)
	unsigned char	type
	const char *	ftype
	const char *	token
	int	storeid
	int	which

int
netsnmp_ds_set_boolean(storeid, which, value)
	int	storeid
	int	which
	int	value

int
netsnmp_ds_set_int(storeid, which, value)
	int	storeid
	int	which
	int	value

int
netsnmp_ds_set_string(storeid, which, value)
	int	storeid
	int	which
	const char *	value

int
netsnmp_ds_set_void(storeid, which, value)
	int	storeid
	int	which
	void *	value

void
netsnmp_ds_shutdown()

int
netsnmp_ds_toggle_boolean(storeid, which)
	int	storeid
	int	which
