#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by generic-table-indexes-set.m2i */
@end@
########################################################################
##
@eval $gtis_tmp=""@
@foreach $node index@
@   include m2c_setup_node.m2i@
@   eval $gtis_tmp="$gtis_tmp, $m2c_node_param_val"@
@end@ # for each index
########################################################################
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'h'@

int ${context}_indexes_set_tbl_idx(${context}_mib_index *tbl_idx$gtis_tmp);
int ${context}_indexes_set(${context}_rowreq_ctx *rowreq_ctx$gtis_tmp);

@end@ // m2c_processing_type eq 'h'
########################################################################
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'c'@
/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
@foreach $node index@
@  if $node.needlength == 1@
 * @param ${node}_ptr
 * @param ${node}_ptr_len
@else@
 * @param ${node}_val
@end@
@end@
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
${context}_indexes_set_tbl_idx(${context}_mib_index *tbl_idx$gtis_tmp)
{
    DEBUGMSGTL(("verbose:${context}:${context}_indexes_set_tbl_idx","called\n"));

@foreach $node index@
@   include m2c_setup_node.m2i@
## table indexes are not allocated pointers, so do not allow realloc here
@eval $m2c_node_realloc = 0@ // fail
    /* $m2c_node_summary */
@   eval $m2c_ctx_lh = "tbl_idx->$node"@
@   eval $m2c_ctx_lhs = "tbl_idx->${node}_len"@
@   eval $m2c_ctx_lhu="elements"@
@   eval $m2c_ctx_rh = "$m2c_node_param_val_name"@
@   eval $m2c_ctx_rhs = "$m2c_node_param_val_lname"@
@   eval $m2c_ctx_rhu="elements"@
@   if $m2c_node_needlength == 1@
    $m2c_ctx_lhs = sizeof($m2c_ctx_lh)/sizeof($m2c_ctx_lh[0]); /* max length */
@   end@
## also, assume mapping already done
@   include generic-ctx-get.m2i@
##@   include generic-value-map.m2i@
    
@end@ // for each column

    return MFD_SUCCESS;
} /* ${context}_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
${context}_indexes_set(${context}_rowreq_ctx *rowreq_ctx$gtis_tmp)
{
    DEBUGMSGTL(("verbose:${context}:${context}_indexes_set","called\n"));

    if(MFD_SUCCESS != ${context}_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
@foreach $node index@
@   include m2c_setup_node.m2i@
                                   , $m2c_node_param_val_call
@end@ # for each index
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != ${context}_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* ${context}_indexes_set */

@end@ // m2c_processing_type eq 'c'
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by generic-table-indexes-set.m2i */
@end@
