#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
########################################################################
########################################################################
##
## mfd function params
##
@ifconf ${name}.m2d@
@   include ${name}.m2d@
@end@
##
## set up defaults
##
@foreach $table table@
@    include default-mfd-top.m2c@ # get defaults
@    eval $context = $table@
##
##   set up defaults
##
@    print Defaults for $table...@
@    eval $m2c_context_reg = "$mfd_default_context_reg"@
@    eval $m2c_data_allocate = $mfd_default_data_allocate@
@    eval $m2c_data_cache = $mfd_default_data_cache@
@    eval $m2c_data_context = "$mfd_default_data_context"@
@    eval $m2c_data_init = $mfd_default_data_init@
@    eval $m2c_data_transient = $mfd_default_data_transient@
@    eval $m2c_include_examples = $mfd_default_include_examples@
@    eval $m2c_irreversible_commit = 0@
@    eval $m2c_table_access = "$mfd_default_table_access"@
@    eval $m2c_table_dependencies = table_is_writable($context)@
@    eval $m2c_table_persistent = 0@
@    eval $m2c_table_row_creation = table_has_create($context)@
@    eval $m2c_table_settable = table_is_writable($context)@
@    eval $m2c_table_skip_mapping = -1@ # -1 = no default; based on type
@    eval $m2c_table_sparse = 0@
@    eval $mfd_generate_makefile = $mfd_default_generate_makefile@
@    eval $mfd_generate_subagent = $mfd_default_generate_subagent@
##
##   allow for user override, or save defaults
##
@    ifconf default-table-${context}.m2d@
@       print Warning: using defaults in current directory. Consider moving@
@       print them to $m2c_defaults_dir.@
@       eval $m2c_defaults_dir = "default-"@
@    end@
@    ifconf ${m2c_defaults_dir}table-${context}.m2d@
@      if $mfd_interactive_setup == 1@
@        print There are existing defaults for $context (${m2c_defaults_dir}table-${context}.m2d).@
@        prompt $ans r)econfigure or u)se existing [default=u] : @
@        if "x$ans" eq "xr"@
@          eval $mfd_interactive_setup = -1@ # already asked to overwrite
@          run -again mfd-interactive-setup.m2c@
@          eval $mfd_interactive_setup = 1@
@        else@
##          ## read in old, write them back (this should add any new vars
@           include ${m2c_defaults_dir}table-${context}.m2d@
@           include m2c_table_save_defaults.m2i@
@        end@ 
@      end@
@    else@ # no existing defaults
@      ifdir defaults@
##       NOP
@      else@
@         perleval my $rc = mkdir(defaults,0775); return $rc != 1 @
@      end@
@      run mfd-interactive-setup.m2c@
@    end@ # no conf file
@end@ # foreach table
@if $m2c_gen_table_defaults == 1@
@   exit@
@end@
@print Starting MFD code generation...@
########################################################################
@eval $m2c_processing_type = 'h'@
@open ${name}.h@
/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-top.m2c
 */
@include generic-header-top.m2i@

/** @addtogroup misc misc: Miscellaneous routines
 *
 * @{
 */
@if $m2c_mark_boundary == 1@
/** START header generated by mfd-top.m2c */
@end@
#include <net-snmp/library/asn1.h>

/* other required module components */
    /* *INDENT-OFF*  */
config_add_mib($name.module)
config_require($name.module/${name}/${name}_interface)
config_require($name.module/${name}/${name}_data_access)
@if $m2c_create_fewer_files != 1@
config_require($name.module/${name}/${name}_data_get)
config_require($name.module/${name}/${name}_data_set)
    /* *INDENT-ON*  */

/* OID and column number definitions for $context */
#include "${name}_oids.h"

/* enum definions */
#include "${name}_enums.h"
@else@
    /* *INDENT-ON*  */

/* OID, column number and enum definions for $context */
#include "${name}_constants.h"
@end@ // m2c_create_fewer_files

/* *********************************************************************
 * function declarations
 */
void init_$name(void);
void shutdown_$context(void);

/* *********************************************************************
 * Table declarations
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@
/* *********************************************************************
 * When you register your mib, you get to provide a generic
 * pointer that will be passed back to you for most of the
 * functions calls.
 *
 * TODO:100:r: Review all context structures
 */
    /*
     * TODO:101:o: |-> Review $context registration context.
     */
@    if "x$m2c_context_reg" eq "x"@
@        eval $m2c_context_reg = "netsnmp_data_list"@
@    end@
typedef $m2c_context_reg ${context}_registration;

@    include generic-data-context.m2i@

@   if $m2c_table_settable@
/* *********************************************************************
 * TODO:115:o: |-> Review $context undo context.
 * We're just going to use the same data structure for our
 * undo_context. If you want to do something more efficent,
 * define your typedef here.
 */
typedef ${context}_data ${context}_undo_data;

@    end@
@    include generic-table-indexes.m2i@

/* *********************************************************************
 * TODO:130:o: |-> Review $context Row request (rowreq) context.
 * When your functions are called, you will be passed a
 * ${context}_rowreq_ctx pointer.
 */
typedef struct ${context}_rowreq_ctx_s {

    /** this must be first for container compare to work */
    netsnmp_index        oid_idx;
##                                             /* xxx-rks: shrink index oid_tmp? */
    oid                  oid_tmp[MAX_${context}_IDX_LEN];
    
    ${context}_mib_index        tbl_idx;
    
@    if $m2c_data_allocate == 1@
@        eval $mfd_tmp = "*"@
@    else@
@        eval $mfd_tmp = " "@
@    end@
    ${context}_data            $mfd_tmp data;
@   if $m2c_table_sparse == 1@
    unsigned int                column_exists_flags; /* flags for existence */
@   end@
@   if $m2c_table_settable@
@      if $m2c_undo_embed == 1@
@         eval $mfd_tmp = " "@
@      else@
@         eval $mfd_tmp = "*"@
@      end@ # embed
    ${context}_undo_data       $mfd_tmp undo;
    unsigned int                column_set_flags; /* flags for set columns */

@   end@ # settable

    /*
     * flags per row. Currently, the first (lower) 8 bits are reserved
     * for the user. See mfd.h for other flags.
     */
    u_int                       rowreq_flags;
@   if $m2c_table_refcounts == 1@
    u_int                       ref_count;
@   end@

    /*
     * TODO:131:o: |   |-> Add useful data to $context rowreq context.
     */
    
    /*
     * storage for future expansion
     */
    netsnmp_data_list             *${context}_data_list;

} ${context}_rowreq_ctx;

typedef struct ${context}_ref_rowreq_ctx_s {
    ${context}_rowreq_ctx *rowreq_ctx;
} ${context}_ref_rowreq_ctx;

/* *********************************************************************
 * function prototypes
 */
## {
    int ${context}_pre_request(${context}_registration * user_context);
    int ${context}_post_request(${context}_registration * user_context,
        int rc);

@   if $m2c_data_init == 1@
    int ${context}_rowreq_ctx_init(${context}_rowreq_ctx *rowreq_ctx,
                                   void *user_init_ctx);
    void ${context}_rowreq_ctx_cleanup(${context}_rowreq_ctx *rowreq_ctx);

@   end@
@    if "$m2c_data_context" ne "generated"@
@        if ($m2c_data_allocate == 1) || ($m2c_undo_embed == 1)@
    ${context}_data * ${context}_allocate_data(void);
    void ${context}_release_data(${context}_data *data);

@        end@
@   end@
@   if $m2c_table_settable@
@      if $m2c_table_dependencies == 1@
    int ${context}_check_dependencies(${context}_rowreq_ctx * rowreq_ctx); 
@      end@ 
    int ${context}_commit(${context}_rowreq_ctx * rowreq_ctx);
@      if $m2c_irreversible_commit == 1@
    int ${context}_irreversible_commit(${context}_rowreq_ctx * rowreq_ctx);
@      end@
@   end@ # writable

    ${context}_rowreq_ctx *
                  ${context}_row_find_by_mib_index(${context}_mib_index *mib_idx);

@   if $m2c_table_refcounts == 1@
int ${context}_row_ref_increment(${context}_rowreq_ctx *rowreq_ctx);
int ${context}_row_ref_decrement(${context}_rowreq_ctx *rowreq_ctx);

@   end@
extern const oid ${context}_oid[];
extern const int ${context}_oid_size;

@end@ # for each

#include "${name}_interface.h"
#include "${name}_data_access.h"
@if $m2c_create_fewer_files != 1@
#include "${name}_data_get.h"
#include "${name}_data_set.h"
@else@
@   eval $mfd_processing_types = "h"@
@   include mfd-data-get.m2c@
@   include mfd-data-set.m2c@
@end@ // m2c_create_fewer_files

/*
 * DUMMY markers, ignore
 *
 * TODO:099:x: *************************************************************
 * TODO:199:x: *************************************************************
 * TODO:299:x: *************************************************************
 * TODO:399:x: *************************************************************
 * TODO:499:x: *************************************************************
 */
@if $m2c_mark_boundary == 1@
/** END header generated by mfd-top.m2c */
@end@
@include generic-header-bottom.m2i@
/** @} */
######################################################################
## Do the .c file
######################################################################
@eval $m2c_processing_type = 'c'@
@open ${name}.c@
/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-top.m2c
 */
/** \page MFD helper for ${name}
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
@include generic-source-includes.m2i@
#include <net-snmp/agent/mib_modules.h>

@if $m2c_mark_boundary == 1@
/** START code generated by mfd-top.m2c */
@end@
#include "${name}_interface.h"

@foreach $table table@
@    include m2c_setup_table.m2i@
const oid ${context}_oid[] = { $context.uc_OID };
const int ${context}_oid_size = OID_LENGTH(${context}_oid);

@    if "x$m2c_context_reg" ne "x"@
    ${context}_registration  ${context}_user_context;
@    end@

void initialize_table_$context(void);
void shutdown_table_$context(void);

@end@

/**
 * Initializes the $name module
 */
void
init_$name(void)
{
    DEBUGMSGTL(("verbose:$name:init_$name","called\n"));

    /*
     * TODO:300:o: Perform $name one-time module initialization.
     */
     
    /*
     * here we initialize all the tables we're planning on supporting
     */
  @foreach $table table@
    if (should_init("$context"))
        initialize_table_$context();

  @end@
} /* init_$name */

/**
 * Shut-down the $name module (agent is exiting)
 */
void
shutdown_$name(void)
{
  @foreach $table table@
    if (should_init("$context"))
        shutdown_table_$context();

  @end@
}

########################################################################
##
@foreach $table table@
@    include m2c_setup_table.m2i@
/**
 * Initialize the table $context 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_$context(void)
{
    ${context}_registration * user_context;
    u_long flags;

    DEBUGMSGTL(("verbose:$context:initialize_table_$context","called\n"));

    /*
     * TODO:301:o: Perform $context one-time table initialization.
     */

    /*
     * TODO:302:o: |->Initialize $context user context
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
@    if "$m2c_context_reg" eq "netsnmp_data_list"@
    /*
     * a netsnmp_data_list is a simple way to store void pointers. A simple
     * string token is used to add, find or remove pointers.
     */
    user_context = netsnmp_create_data_list("$context", NULL, NULL);
@    else@
    user_context = &${context}_user_context;
@   end@
    
    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;
    
    /*
     * call interface initialization code
     */
    _${context}_initialize_interface(user_context, flags);
} /* initialize_table_$context */

/**
 * Shutdown the table $context 
 */
void
shutdown_table_$context(void)
{
    /*
     * call interface shutdown code
     */
    _${context}_shutdown_interface(&${context}_user_context);
}

########################################################################
@   if $m2c_data_init == 1@
/**
 * extra context initialization (eg default values)
 *
 * @param rowreq_ctx    : row request context
 * @param user_init_ctx : void pointer for user (parameter to rowreq_ctx_allocate)
 *
 * @retval MFD_SUCCESS  : no errors
 * @retval MFD_ERROR    : error (context allocate will fail)
 */
int
${context}_rowreq_ctx_init(${context}_rowreq_ctx *rowreq_ctx,
                           void *user_init_ctx)
{
    DEBUGMSGTL(("verbose:$context:${context}_rowreq_ctx_init","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);
    
    /*
     * TODO:210:o: |-> Perform extra $context rowreq initialization. (eg DEFVALS)
     */
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
@      if $node.hasdefval == 0@
@         next@
@      end@
##------------------------------------------------------
@      if $node.needlength == 1@
    /*
     * strings and oids are hard to handle automagically.
     * so all we've got for you is a hint:
     *
     * memcpy($m2c_data_item$node, $node.defval,
     *        len($node.defval) * sizeof($m2c_data_itme$node[0]);
     */
@      elsif $node.enums == 1@
@         if "$node.perltype" ne "BITS"@
@            eval $m2c_tmp_mt = $node.defval@
@            foreach $e $v enum@
@               include m2c_setup_enum.m2i@
@               if $e eq $node.defval@
@                  eval $m2c_tmp_mt = $m2c_ename@
@               end@
@            end@ # for each
@         end@ # ! bits
    $m2c_data_item$node = $m2c_tmp_mt;
@      elsif ("$node.decl" eq "long") || ("$node.decl" eq "u_long")@
    $m2c_data_item$node = $node.defval;
@      else@
    /** $m2c_data_item$node = $node.defval; */
@      end@
    
@   end@ foreach nonindex

    return MFD_SUCCESS;
} /* ${context}_rowreq_ctx_init */

/**
 * extra context cleanup
 *
 */
void ${context}_rowreq_ctx_cleanup(${context}_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:$context:${context}_rowreq_ctx_cleanup","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);
    
    /*
     * TODO:211:o: |-> Perform extra $context rowreq cleanup.
     */
} /* ${context}_rowreq_ctx_cleanup */

@   end@ // data_init
########################################################################
@if $m2c_table_persistent == 1@
@   include mfd-persistence.m2i@
@end@
########################################################################
/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
${context}_pre_request(${context}_registration * user_context)
{
    DEBUGMSGTL(("verbose:${context}:${context}_pre_request","called\n"));

    /*
     * TODO:510:o: Perform $context pre-request actions.
     */

    return MFD_SUCCESS;
} /* ${context}_pre_request */

/**
 * post-request callback
 *
 * Note:
 *   New rows have been inserted into the container, and
 *   deleted rows have been removed from the container and
 *   released.
 *
 * @param user_context
 * @param rc : MFD_SUCCESS if all requests succeeded
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
${context}_post_request(${context}_registration * user_context, int rc)
{
    DEBUGMSGTL(("verbose:${context}:${context}_post_request","called\n"));

    /*
     * TODO:511:o: Perform $context post-request actions.
     */

@  if $m2c_table_settable@
    /*
     * check to set if any rows were changed.
     */
    if (${context}_dirty_get()) {
        /*
         * check if request was successful. If so, this would be
         * a good place to save data to its persistent store.
         */
        if (MFD_SUCCESS == rc) {
            /*
             * save changed rows, if you haven't already
             */
@     if $m2c_table_persistent@
            snmp_store(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
                                             NETSNMP_DS_LIB_APPTYPE));
@     end@
        }
        
        ${context}_dirty_set(0); /* clear table dirty flag */
    }

@   end@
    return MFD_SUCCESS;
} /* ${context}_post_request */

@end@ // table

########################################################################
@if $m2c_create_fewer_files == 1@
@   eval $mfd_processing_types = "c"@
@   include mfd-data-get.m2c@
@   include mfd-data-set.m2c@
@else@
@   eval $mfd_processing_types = "chi"@
@   run mfd-data-get.m2c@
@   run mfd-data-set.m2c@
@end@
########################################################################
/** @{ */
@if $m2c_mark_boundary == 1@
/** END code generated by mfd-top.m2c */
@end@
##
########################################################################
##
## Do support files
##
########################################################################
@run generic-table-constants.m2c@
@run mfd-interface.m2c@
@run mfd-data-access.m2c@
##
@run mfd-readme.m2c@
##
@if $mfd_generate_doxygen == 1@
@   run mfd-doxygen.m2c@
@end@
##
@if $mfd_generate_makefile == 1@
@   run mfd-makefile.m2m@
@end@
##
@if $mfd_generate_subagent == 1@
@   run subagent.m2c@
@end@
##
