.TH "tdata" 3 "3 Feb 2009" "Version 5.3.2" "net-snmp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tdata \- Implement a table with datamatted storage.  

.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_netsnmp_tdata_generate_index_oid\fP (netsnmp_tdata_row *row)"
.br
.ti -1c
.RI "netsnmp_tdata * \fBnetsnmp_tdata_create_table\fP (const char *name, long flags)"
.br
.RI "\fIcreates and returns a 'tdata' table data structure \fP"
.ti -1c
.RI "void \fBnetsnmp_tdata_delete_table\fP (netsnmp_tdata *table)"
.br
.RI "\fIcreates and returns a 'tdata' table data structure \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_create_row\fP (void)"
.br
.RI "\fIcreates and returns a pointer to new row data structure \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_clone_row\fP (netsnmp_tdata_row *row)"
.br
.RI "\fIclones a 'tdata' row. \fP"
.ti -1c
.RI "int \fBnetsnmp_tdata_copy_row\fP (netsnmp_tdata_row *dst_row, netsnmp_tdata_row *src_row)"
.br
.RI "\fIcopy the contents of a 'tdata' row. \fP"
.ti -1c
.RI "void * \fBnetsnmp_tdata_delete_row\fP (netsnmp_tdata_row *row)"
.br
.RI "\fIdeletes the memory used by the specified row returns the table-specific entry data (that it doesn't know how to delete) \fP"
.ti -1c
.RI "int \fBnetsnmp_tdata_add_row\fP (netsnmp_tdata *table, netsnmp_tdata_row *row)"
.br
.RI "\fIAdds a row to the given table (stored in proper lexographical order). \fP"
.ti -1c
.RI "void \fBnetsnmp_tdata_replace_row\fP (netsnmp_tdata *table, netsnmp_tdata_row *origrow, netsnmp_tdata_row *newrow)"
.br
.RI "\fIswaps out origrow with newrow. \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_remove_row\fP (netsnmp_tdata *table, netsnmp_tdata_row *row)"
.br
.RI "\fIremoves a row from the given table and returns it (no free's called) \fP"
.ti -1c
.RI "void * \fBnetsnmp_tdata_remove_and_delete_row\fP (netsnmp_tdata *table, netsnmp_tdata_row *row)"
.br
.RI "\fIremoves and frees a row of the given table and returns the table-specific entry data \fP"
.ti -1c
.RI "\fBnetsnmp_mib_handler\fP * \fBnetsnmp_get_tdata_handler\fP (netsnmp_tdata *table)"
.br
.RI "\fICreates a tdata handler and returns it. \fP"
.ti -1c
.RI "int \fB_netsnmp_tdata_helper_handler\fP (\fBnetsnmp_mib_handler\fP *handler, \fBnetsnmp_handler_registration\fP *reginfo, \fBnetsnmp_agent_request_info\fP *reqinfo, \fBnetsnmp_request_info\fP *requests)"
.br
.ti -1c
.RI "int \fBnetsnmp_tdata_register\fP (\fBnetsnmp_handler_registration\fP *reginfo, netsnmp_tdata *table, \fBnetsnmp_table_registration_info\fP *table_info)"
.br
.RI "\fIregisters a tdata-based MIB table \fP"
.ti -1c
.RI "netsnmp_tdata * \fBnetsnmp_tdata_extract_table\fP (\fBnetsnmp_request_info\fP *request)"
.br
.RI "\fIextracts the tdata table from the request structure \fP"
.ti -1c
.RI "netsnmp_container * \fBnetsnmp_tdata_extract_container\fP (\fBnetsnmp_request_info\fP *request)"
.br
.RI "\fIextracts the tdata container from the request structure \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_extract_row\fP (\fBnetsnmp_request_info\fP *request)"
.br
.RI "\fIextracts the tdata row being accessed from the request structure \fP"
.ti -1c
.RI "void * \fBnetsnmp_tdata_extract_entry\fP (\fBnetsnmp_request_info\fP *request)"
.br
.RI "\fIextracts the (table-specific) entry being accessed from the request structure \fP"
.ti -1c
.RI "NETSNMP_INLINE void \fBnetsnmp_insert_tdata_row\fP (\fBnetsnmp_request_info\fP *request, netsnmp_tdata_row *row)"
.br
.RI "\fIinserts a newly created tdata row into a request \fP"
.ti -1c
.RI "void * \fBnetsnmp_tdata_row_entry\fP (netsnmp_tdata_row *row)"
.br
.RI "\fIreturns the (table-specific) entry data for a given row \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_first\fP (netsnmp_tdata *table)"
.br
.RI "\fIreturns the first row in the table \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_get\fP (netsnmp_tdata *table, netsnmp_tdata_row *row)"
.br
.RI "\fIfinds a row in the 'tdata' table given another row \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_next\fP (netsnmp_tdata *table, netsnmp_tdata_row *row)"
.br
.RI "\fIreturns the next row in the table \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_get_byidx\fP (netsnmp_tdata *table, \fBnetsnmp_variable_list\fP *indexes)"
.br
.RI "\fIfinds a row in the 'tdata' table given the index values \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_get_byoid\fP (netsnmp_tdata *table, oid *searchfor, size_t searchfor_len)"
.br
.RI "\fIfinds a row in the 'tdata' table given the index OID \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_next_byidx\fP (netsnmp_tdata *table, \fBnetsnmp_variable_list\fP *indexes)"
.br
.RI "\fIfinds the lexically next row in the 'tdata' table given the index values \fP"
.ti -1c
.RI "netsnmp_tdata_row * \fBnetsnmp_tdata_row_next_byoid\fP (netsnmp_tdata *table, oid *searchfor, size_t searchfor_len)"
.br
.RI "\fIfinds the lexically next row in the 'tdata' table given the index OID \fP"
.ti -1c
.RI "int \fBnetsnmp_tdata_row_count\fP (netsnmp_tdata *table)"
.br
.ti -1c
.RI "int \fBnetsnmp_tdata_compare_idx\fP (netsnmp_tdata_row *row, \fBnetsnmp_variable_list\fP *indexes)"
.br
.RI "\fIcompare a row with the given index values \fP"
.ti -1c
.RI "int \fBnetsnmp_tdata_compare_oid\fP (netsnmp_tdata_row *row, oid *compareto, size_t compareto_len)"
.br
.RI "\fIcompare a row with the given index OID \fP"
.ti -1c
.RI "int \fBnetsnmp_tdata_compare_subtree_idx\fP (netsnmp_tdata_row *row, \fBnetsnmp_variable_list\fP *indexes)"
.br
.ti -1c
.RI "int \fBnetsnmp_tdata_compare_subtree_oid\fP (netsnmp_tdata_row *row, oid *compareto, size_t compareto_len)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "Netsnmp_Node_Handler \fB_netsnmp_tdata_helper_handler\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Implement a table with datamatted storage. 

This helper helps you implement a table where all the rows are expected to be stored within the agent itself and not in some external storage location. It can be used to store a list of rows, where a row consists of the indexes to the table and a generic data pointer. You can then implement a subhandler which is passed the exact row definition and data it must return data for or accept data for. Complex GETNEXT handling is greatly simplified in this case. 
.SH "Function Documentation"
.PP 
.SS "\fBnetsnmp_mib_handler\fP* netsnmp_get_tdata_handler (netsnmp_tdata * table)"
.PP
Creates a tdata handler and returns it. 
.PP
Definition at line 284 of file table_tdata.c.
.SS "NETSNMP_INLINE void netsnmp_insert_tdata_row (\fBnetsnmp_request_info\fP * request, netsnmp_tdata_row * row)"
.PP
inserts a newly created tdata row into a request 
.PP
Definition at line 399 of file table_tdata.c.
.SS "int netsnmp_tdata_add_row (netsnmp_tdata * table, netsnmp_tdata_row * row)"
.PP
Adds a row to the given table (stored in proper lexographical order). 
.PP
returns SNMPERR_SUCCESS on successful addition. or SNMPERR_GENERR on failure (E.G., indexes already existed) 
.PP
Definition at line 186 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_clone_row (netsnmp_tdata_row * row)"
.PP
clones a 'tdata' row. 
.PP
DOES NOT CLONE THE TABLE-SPECIFIC ENTRY DATA. 
.PP
Definition at line 92 of file table_tdata.c.
.SS "int netsnmp_tdata_compare_idx (netsnmp_tdata_row * row, \fBnetsnmp_variable_list\fP * indexes)"
.PP
compare a row with the given index values 
.PP
Definition at line 518 of file table_tdata.c.
.SS "int netsnmp_tdata_compare_oid (netsnmp_tdata_row * row, oid * compareto, size_t compareto_len)"
.PP
compare a row with the given index OID 
.PP
Definition at line 531 of file table_tdata.c.
.SS "int netsnmp_tdata_copy_row (netsnmp_tdata_row * dst_row, netsnmp_tdata_row * src_row)"
.PP
copy the contents of a 'tdata' row. 
.PP
DOES NOT COPY THE TABLE-SPECIFIC ENTRY DATA. 
.PP
Definition at line 129 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_create_row (void)"
.PP
creates and returns a pointer to new row data structure 
.PP
Definition at line 84 of file table_tdata.c.
.SS "netsnmp_tdata* netsnmp_tdata_create_table (const char * name, long flags)"
.PP
creates and returns a 'tdata' table data structure 
.PP
Definition at line 54 of file table_tdata.c.
.SS "void* netsnmp_tdata_delete_row (netsnmp_tdata_row * row)"
.PP
deletes the memory used by the specified row returns the table-specific entry data (that it doesn't know how to delete) 
.PP
Definition at line 157 of file table_tdata.c.
.SS "void netsnmp_tdata_delete_table (netsnmp_tdata * table)"
.PP
creates and returns a 'tdata' table data structure 
.PP
Definition at line 68 of file table_tdata.c.
.SS "netsnmp_container* netsnmp_tdata_extract_container (\fBnetsnmp_request_info\fP * request)"
.PP
extracts the tdata container from the request structure 
.PP
Definition at line 370 of file table_tdata.c.
.SS "void* netsnmp_tdata_extract_entry (\fBnetsnmp_request_info\fP * request)"
.PP
extracts the (table-specific) entry being accessed from the request structure 
.PP
Definition at line 387 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_extract_row (\fBnetsnmp_request_info\fP * request)"
.PP
extracts the tdata row being accessed from the request structure 
.PP
Definition at line 379 of file table_tdata.c.
.SS "netsnmp_tdata* netsnmp_tdata_extract_table (\fBnetsnmp_request_info\fP * request)"
.PP
extracts the tdata table from the request structure 
.PP
Definition at line 362 of file table_tdata.c.
.SS "int netsnmp_tdata_register (\fBnetsnmp_handler_registration\fP * reginfo, netsnmp_tdata * table, \fBnetsnmp_table_registration_info\fP * table_info)"
.PP
registers a tdata-based MIB table 
.PP
Definition at line 351 of file table_tdata.c.
.SS "void* netsnmp_tdata_remove_and_delete_row (netsnmp_tdata * table, netsnmp_tdata_row * row)"
.PP
removes and frees a row of the given table and returns the table-specific entry data 
.PP
returns the void * pointer on successful deletion. or NULL on failure (bad arguments) 
.PP
Definition at line 260 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_remove_row (netsnmp_tdata * table, netsnmp_tdata_row * row)"
.PP
removes a row from the given table and returns it (no free's called) 
.PP
returns the row pointer itself on successful removing. or NULL on failure (bad arguments) 
.PP
Definition at line 242 of file table_tdata.c.
.SS "void netsnmp_tdata_replace_row (netsnmp_tdata * table, netsnmp_tdata_row * origrow, netsnmp_tdata_row * newrow)"
.PP
swaps out origrow with newrow. 
.PP
This does *not* delete/free anything! 
.PP
Definition at line 227 of file table_tdata.c.
.SS "void* netsnmp_tdata_row_entry (netsnmp_tdata_row * row)"
.PP
returns the (table-specific) entry data for a given row 
.PP
Definition at line 414 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_first (netsnmp_tdata * table)"
.PP
returns the first row in the table 
.PP
Definition at line 424 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_get (netsnmp_tdata * table, netsnmp_tdata_row * row)"
.PP
finds a row in the 'tdata' table given another row 
.PP
Definition at line 431 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_get_byidx (netsnmp_tdata * table, \fBnetsnmp_variable_list\fP * indexes)"
.PP
finds a row in the 'tdata' table given the index values 
.PP
Definition at line 447 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_get_byoid (netsnmp_tdata * table, oid * searchfor, size_t searchfor_len)"
.PP
finds a row in the 'tdata' table given the index OID 
.PP
Definition at line 460 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_next (netsnmp_tdata * table, netsnmp_tdata_row * row)"
.PP
returns the next row in the table 
.PP
Definition at line 439 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_next_byidx (netsnmp_tdata * table, \fBnetsnmp_variable_list\fP * indexes)"
.PP
finds the lexically next row in the 'tdata' table given the index values 
.PP
Definition at line 475 of file table_tdata.c.
.SS "netsnmp_tdata_row* netsnmp_tdata_row_next_byoid (netsnmp_tdata * table, oid * searchfor, size_t searchfor_len)"
.PP
finds the lexically next row in the 'tdata' table given the index OID 
.PP
Definition at line 489 of file table_tdata.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for net-snmp from the source code.
